/*
 * Copyright (c) 2011-2012, Yahoo! Inc.  All rights reserved.
 * Copyrights licensed under the New BSD License.
 * See the accompanying LICENSE file for terms.
 */
var path = require('path'),
    utils = require('mojito/lib/management/utils'),
    fs = require('fs'),
    Queue = require('buildy').Queue,
    Registry = require('buildy').Registry,
    ShakerCore = require('./core').ShakerCore,
    async = require('async'),
    mkdirp = require('mkdirp'),
    mime = require('mime');

/**
 * Shaker compiler.
 *
 * Compiler takes metadata generated by the core and depending on the environment context
 * will run tasks against the assets. Tasks including concatenating, minifying, and deploying to
 * a variety of locations (local, cdn).
 *
 * Sample application.json:
 *   ...
 *   {
 *       "settings": ["environment:test"],
 *       "shaker": {
 *           "task": "local"
 *       }
 *   },
 *   ...
 *
 * Example:
 * var store = new ResourceStore('./');
 * new Shaker(store).run(function(metadata) {
 *    console.log(metadata);
 * )});
 *
 * @param store {Object} The store object belonging to a Mojito app.
 */
function Shaker(store) {
    this._store = store;

    var config = this._store.getAppConfig(null, 'definition') || {},
        specs = config.specs || {},
        appConfig = specs.staticHandling || {};

    this._prefix = '/static';
    if (typeof appConfig.prefix !== 'undefined') {
        this._prefix = appConfig.prefix ? '/' + appConfig.prefix : '';
    }

    var shaker = config.shaker !== undefined ? config.shaker : {};
    this._compile = config.shaker !== undefined;
    this._task = shaker.task !== undefined ? shaker.task : 'local';
    this._images = shaker.images !== undefined ? shaker.images : false;
    this._parallel = shaker.parallel !== undefined ? shaker.parallel : 20;
    this._delay = shaker.delay !== undefined ? shaker.delay : 0;
    this._concat = shaker.concat !== undefined ? shaker.concat : true;
    this._minify = shaker.minify !== undefined ? shaker.minify : true;
    this._config = shaker.config !== undefined ? shaker.config : {};
    this._config.root = this._prefix + '/' + this._store._shortRoot + '/';
}

Shaker.TASKS_DIR = __dirname + '/tasks/';
Shaker.ASSETS_DIR = 'assets/';
Shaker.COMPILED_DIR = Shaker.ASSETS_DIR + 'compiled/';
Shaker.IMAGES_DIR = Shaker.ASSETS_DIR + 'images/';

Shaker.prototype = {
    run: function(callback) {
        utils.log('[SHAKER] - Analizying application assets to Shake... ');
        var metadata = new ShakerCore({store: this._store}).shakeAll();

        if (this._compile) {
            this._compileRollups(metadata, callback);
        } else {
            metadata = this._rename(metadata); // TODO: rename should be unnecessary if core keeps mapping of urls -> files
            this._writeMeta(metadata);
            callback(metadata);
        }
    },

    _rename: function(metadata, callback){
        utils.log('[SHAKER] - Processing assets for development env.');
        var mojit, action, dim, item, list;

        for (mojit in metadata.mojits) {
            for (action in metadata.mojits[mojit]) {
                for (dim in metadata.mojits[mojit][action].shaken) {
                    for (item in metadata.mojits[mojit][action].shaken[dim]) {
                        list = metadata.mojits[mojit][action].shaken[dim];
                        list[item] = list[item].replace(this._store._root + '/mojits', this._prefix);
                    }
                }
            }
        }

        for (action in metadata.app) {
            for (dim in metadata.app[action].shaken) {
                for (item in (list = metadata.app[action].shaken[dim])) {
                    var aux = list[item].replace(this._store._root, this._prefix + '/' + this._store._shortRoot);
                    aux = aux.replace(this._prefix + '/' + this._store._shortRoot + '/mojits', this._prefix);
                    list[item] = aux;
                }
            }
        }

        return metadata;
    },

    _compileRollups: function(metadata, compressed) {
        utils.log('[SHAKER] - Compiling rollups...');

        var registry = new Registry();
        registry.load(Shaker.TASKS_DIR);

        var self = this;
        var queue = async.queue(function(item, callback) {
            setTimeout(function() {
                var options = {task: self._task, concat: self._concat, minify: self._minify, config: self._config};
                item.object.push(registry, options, function(err, url) {
                    utils.log('[SHAKER] - Pushed file ' + url);
                    item.files.push(url);
                    callback();
                });
            }, self._delay);
        }, this._parallel);

        queue.drain = function() {
            self._writeMeta(metadata);
            compressed(metadata);
        };

        this._queueRollups(queue, metadata);
    },

    _queueRollups: function(queue, metadata) {
        var mojit, action, dim, files, name, filtered;

        if (this._images) {
            metadata.images.forEach(function(image) {
                queue.push({object: new Image(Shaker.IMAGES_DIR + path.basename(image), image), files: metadata.images});
            });
            metadata.images.length = 0;
        }

        queue.push({object: new Rollup(Shaker.COMPILED_DIR + 'mojito_core_{checksum}.js', metadata.core.slice() /* Clone array */), files: metadata.core});
        metadata.core.length = 0;

        for (mojit in metadata.mojits) {
            for (action in metadata.mojits[mojit]) {
                for (dim in (files = metadata.mojits[mojit][action].shaken)) {
                    if (files[dim].length) {
                        name = mojit + '_' + action.replace('*', 'default') + '_{checksum}';
                        filtered = this._filterFiles(files[dim]);

                        if (filtered.js.length) {
                            queue.push({object: new Rollup(Shaker.COMPILED_DIR + name + '.js', filtered.js), files: files[dim]});
                        }
                        if (filtered.css.length) {
                            queue.push({object: new Rollup(Shaker.COMPILED_DIR + name + '.css', filtered.css), files: files[dim]});
                        }
                        files[dim].length = 0;
                    }
                }
            }
        }

        for (action in metadata.app) {
            for (dim in (files = metadata.app[action].shaken)) {
                if (files[dim].length) {
                    name = 'app_' + action.replace('*', 'default') + '_{checksum}';
                    filtered = this._filterFiles(files[dim]);

                    if (filtered.js.length) {
                        queue.push({object: new Rollup(Shaker.COMPILED_DIR + name + '.js', filtered.js), files: files[dim]});
                    }
                    if (filtered.css.length) {
                        queue.push({object: new Rollup(Shaker.COMPILED_DIR + name + '.css', filtered.css), files: files[dim]});
                    }
                    files[dim].length = 0;
                }
            }
        }
    },

    _filterFiles: function(files) {
        var js = [], css = [];

        files.forEach(function(file) {
            var type = mime.lookup(file);

            if (type === 'application/javascript') {
                js.push(file);
            }
            else if (type === 'text/css') {
                css.push(file);
            }
        });

        return {'js': js, 'css': css};
    },

    _writeMeta:function(metadata){
        var self = this, aux = "";
        aux += 'YUI.add("shaker/metaMojits", function(Y, NAME) {\n';
        aux += 'YUI.namespace("_mojito._cache.shaker");\n';
        aux += 'YUI._mojito._cache.shaker.meta = \n';
        aux += JSON.stringify(metadata,null,'\t');
        aux += '});';

        utils.log('[SHAKER] - Writting addon metadata file');
        mkdirp.sync(self._store._root + '/autoload/compiled', 0777 & (~process.umask()));
        fs.writeFileSync(self._store._root + '/autoload/compiled/shaker.server.js', aux);
    }
};

function Image(name, file) {
    this._name = name;
    this._file = file;
}

Image.prototype = {
    push: function(registry, options, callback) {
        var queue = new Queue('Rollup', {registry: registry});

        queue.task('files', [this._file]);

        options.config.name = this._name;
        queue.task(options.task, options.config);

        queue.on('taskComplete', function(data) { // queueFailed, queueComplete
            if (data.task.type === options.task) {
                callback(null, data.result);
            }
        });

        queue.run();
    }
};

function Rollup(name, files) {
    this._name = name;
    this._files = files;
}

Rollup.prototype = {
    push: function(registry, options, callback) {
        var queue = new Queue('Rollup', {registry: registry});

        queue.task('files', this._files);

        if (options.concat) {
            queue.task('concat');
        }

        if (options.minify) {
            queue.task(mime.lookup(this._name) === 'application/javascript' ? 'jsminify' : 'cssminify');
        }

        options.config.name = this._name;
        queue.task(options.task, options.config);

        queue.on('taskComplete', function(data) { // queueFailed, queueComplete
            if (data.task.type === options.task) {
                callback(null, data.result);
            }
        });

        queue.run();
    }
};

exports.Shaker = Shaker;
